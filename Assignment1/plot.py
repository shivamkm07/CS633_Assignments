import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
import numpy as np

count_executions = 5
P_list = [16, 36, 49, 64]
N_list = [16, 32, 64, 128, 256, 512, 1024]

fig, ax = plt.subplots(figsize=(30, 10))

count = len(P_list)*len(N_list)*3

# Read Sequence of times generated by src.c
Times = []
with open("data", "r") as file1:
    for line in file1:
        Times.append(float(line.strip('\n')))

# Segregrate the "time series" into data blocks for each P value using Dictionary.
# For each P value, the structure of the 3d array is #count_executtion (5) * Data_points_per_process ðŸ‘Ž * #methods (3)
# A sample output is shown:
# {16: array([[[0.829921, 0.291374, 0.934776],
#         [1.274071, 0.891392, 0.619952],
#         [2.258782, 0.87556 , 0.815875],
#         [2.298441, 0.982404, 0.601146],
#         [4.848607, 0.793188, 0.867024],
#         [4.987791, 1.074563, 0.970192],
#         [9.166652, 4.721061, 1.785095]],

#        [[0.837431, 0.667861, 0.801447],
#         [1.237437, 0.815843, 0.591931],
#         [0.704736, 0.458708, 0.667828],
#         [3.374277, 0.943043, 1.011935],
#         [5.308223, 0.964686, 0.914451],
#         [6.599928, 1.51278 , 1.091096],
#         [9.038267, 2.208861, 2.34778 ]],

#        [[0.894508, 0.707701, 0.848848],
#         [1.000537, 0.909932, 0.794178],
#         [0.372394, 0.032142, 0.030968],
#         [1.535346, 0.715879, 0.614578],
#         [3.975727, 0.227933, 0.607519],
#         [3.342936, 0.666124, 0.853884],
#         [7.697041, 1.876039, 1.762471]],

#        [[0.698934, 0.647798, 0.668005],
#         [1.240644, 0.843796, 0.857377],
#         [1.400476, 0.695493, 0.767351],
#         [3.278027, 0.963692, 0.827768],
#         [4.557504, 0.758991, 0.619956],
#         [4.162894, 0.991349, 0.842494],
#         [9.079352, 2.417467, 1.736327]],

#        [[1.445314, 0.482782, 0.555987],
#         [0.77857 , 0.462052, 0.50585 ],
#         [1.066272, 0.187621, 0.431577],
#         [2.39224 , 0.536132, 0.403623],
#         [2.717489, 0.767271, 0.435971],
#         [2.593079, 0.74396 , 0.875451],
#         [6.410795, 1.765727, 1.492   ]]]), 32: .... }

plot_data = {}
for p in P_list:
    plot_data[p] = []

# Segregrating Data into matrices for each P values as shown above
for i in range(count_executions):

    start_index = i*count
    end_index = (i+1)*count

    for p in range(len(P_list)):

        start_P = start_index + p*len(N_list)*3

        plot_data[P_list[p]].append([Times[i:i + 3] for i in range(start_P, start_P + 3*len(N_list), 3)])

# Set colours and positions for the boxplots of each method per N value
colours = [['blue', 'lightblue'],['darkgreen','lightgreen'], ['red', 'yellow']]
positions = [[1, 1.5, 2, 2.5, 3, 3.5, 4],[1.1, 1.6, 2.1, 2.6, 3.1, 3.6, 4.1],[1.2, 1.7, 2.2, 2.7, 3.2, 3.7, 4.2]]

# Helper Function to make boxplot for each chunk of 5 value large data array (per N per method)
def make_boxplot(data, labels, edge_colours, fill_colours, positions):
    box_plot = ax.boxplot(data, positions = positions ,labels = labels, widths = 0.075, patch_artist=True)    
    ax.set_yscale('log')
    ax.set_ylabel('Execution Time (seconds)')
    ax.set_xlabel('Array Size per Process (n*n)')
    
    for ele in ['boxes', 'whiskers', 'fliers', 'means', 'medians', 'caps']:
        plt.setp(box_plot[ele], color = edge_colours)
    
    for patch in box_plot['boxes']:
        patch.set(facecolor = fill_colours) 

    return box_plot

#Convert 3d nested list to 3d Numpy array for ease in indexing into the elements
for p in P_list:
    plot_data[p] = np.array(plot_data[p])

# Using calling function to make the boxplots for each value of P
for p in P_list:
    boxes = {}
    for method in range(3):
        P_n_method_data = []
        label = []
        for n in range(len(N_list)):
            P_n_method_data.append(plot_data[p][:, n, method])
            label.append(str(N_list[n])+"*"+str(N_list[n]))

        boxes[method] = make_boxplot(P_n_method_data, label, colours[method][0], colours[method][1], positions[method])

    ax.legend([boxes[0]["boxes"][0], boxes[1]["boxes"][0], boxes[2]["boxes"][0]], ['Method 1', 'Method 2', 'Method 3'], loc = 'upper right')

    plt.tight_layout()
    ax.set_xlim(0.75, 4.45)
    fig.savefig('plot'+str(p)+'.png', dpi=fig.dpi)
    fig, ax = plt.subplots(figsize=(30, 10))
